#include "../GeneralClasses/IncludeFile.h"

int main (void){

    ofstream out;
    out.open("data.dat");

    FILE *fp;

    fp = popen( "gnuplot -persist", "w" );

    double r_metal;                 // Metal refractive index (real part)
    double i_metal;                 // Metal refractive index (imaginary part)
    double d_metal;                 // Layer thickness value (nm)
    double d_silica;                // Silica thickness value (nm)
    double d_au;                    // Gold metal layer thickness (nm)
    double d_analyte;               // Analyte layer thickness (nm)
    double n_prism; 		        // Prism refractive index
    double n_analyte;               // Analyte refractive index
    double n_silica;                // Silica refractive index
	double wavelength;		        // Incident wavelength
    double R_AIM;                   // Angular Reflectance Variable
    double R_WIM;                   // Wavelength Reflectance Variable
    double T_AIM;                   // Angular Transmission Intensity Variable
    double L;                       // Length of the exposed sensing region
    double theta_i = 0;             // Start Incident Angle (in radians -> 10 degrees)
    double theta_spr;               // Resonant Angle for WIM operation mode
    double n, k;                    // Refractive Index Coefficients
        
    unsigned int N = 3;             // Set number of layers
    
    double step_scale = 0.001;      // Set the step scale interval

	int interface, choose, mode;

    double real[N], *r;
    r = &real[0]; 

    double imag[N], *i;        
    i = &imag[0];

    double thickness[N], *d;        
    d = &thickness[0];

    Timer timer;

    cout <<
	"|----------------------------------------------------------------------------------------------|" << "\n"
	"|------------------------------------- Welcome to Sim-SPR -------------------------------------|" << "\n" 
	"| Sim-SPR is an open-source SPR simulator developed for the study of Surface Plasmon Resonance |" << "\n"
    "| of different materials using AIM and WIM operational modes. In particular, Sim-SPR involved  |" << "\n"
    "| the numerical analysis of angular and spectral variation of reflectance calculated by using  |" << "\n"
    "| characteristic transfer matrix method. Sim-SPR works for Kretschmann, Otto & Optical Fibers  |" << "\n"
    "| configurations. The accuracy, efficiency and reliability of the Sim-SPR were validated by    |" << "\n"
    "| comparing results generated by using other simulation tools already consolidated in the lite-|" << "\n"
    "| rature and results of SPR experiments with standard samples.                                 |" << "\n"
	"|----------------------------------------------------------------------------------------------|" << "\n\n";

	cout << "# Choose the configuration and type the respective number:" << endl << endl;

    cout << "(1) Kretschmann-Raether" << endl;
    cout << "(2) Turbadar-Otto" << endl;
    cout << "(3) Optical Fiber" << endl << endl;

    cin >> choose;

    cout << endl;

    // ***
    // Angular Interrogation Mode (AIM)
    // ***    

    if(choose == 1){

        cout << "# Angular Interrogation (1) or Wavelength Interrogation (2):" << endl;
        cin >> mode;

        cout << "# Type the incident light wavelength [nm]:" << endl;
        cin >> wavelength;

        cout << "# Type the prism refractive index:" << endl;
        cin >> n_prism;                    
    }

    if(choose == 2){

        cout << "# Type the incident light wavelength [nm]:" << endl;
        cin >> wavelength;

        cout << "# Type the prism refractive index:" << endl;
        cin >> n_prism;
    }

    if (choose == 3){

        cout << "# Angular Interrogation (1) or Wavelength Interrogation (2):" << endl;
        cin >> mode;

        if(mode == 1){
            cout << "# Type the incident light wavelength [nm]:" << endl;
            cin >> wavelength;

            cout << "# Type the silica refractive index:" << endl;
            cin >> n_silica;

            cout << "# Type the silica layer thickness [um]:" << endl;
            cin >> d_silica;
        }
        if(mode == 2){
            cout << "# Type the resonant angle:" << endl;
            cin >> theta_i;

            cout << "# Type the silica refractive index:" << endl;
            cin >> n_silica;

            cout << "# Type the silica layer thickness [um]:" << endl;
            cin >> d_silica;

            cout << "# Type the metal layer thickness [nm]:" << endl;
            cin >> d_au;

            cout << "# Type the analyte refractive index:" << endl;
            cin >> n_analyte;

            cout << "# Type the analyte layer thickness [nm]:" << endl;
            cin >> d_analyte;

        }       

    }

    if((choose == 1 || choose == 2) || (choose == 3 && mode == 1)) {
        for (interface = 1; interface < N; interface++){

            cout << "Layer | Type the refractive index:" << endl;
            cout << interface << "\t" << "Real part" << "\t\t:";
            cin >> r_metal;
            
            cout << "Layer | Type the refractive index:" << endl;
            cout << interface << "\t" << "Imaginary part" << "\t\t:";
            cin >> i_metal;

            cout << "Layer | Type the layer thickness [nm]:" << endl;
            cout << interface << "\t" << "Layer thickness" << "\t\t:";
            cin >> d_metal;

            getchar();

            *(r+interface) = r_metal; 
            *(i+interface) = i_metal; 
            *(d+interface) = d_metal; 
        } 
    }   

    // ***
    // Kretschmann-Raether configuration
    // ***

    if (choose == 1){
        if (N == 3){            
            if(mode == 1){           
                while (theta_i <= 1.5707){  // 90 in degrees                    
                    out << (theta_i * (180/M_PI)) << "\t\t" << kre_3.Reflectance(wavelength, n_prism, real[2], theta_i, real[1], imag[1], thickness[1]) << endl;
                    theta_i += step_scale; 
                }
            }
        }
    }
    
    // ***
    // Turbadar-Otto configuration
    // ***

    if(choose == 2){
    // Start timer
    timer.start();
        while (theta_i <= 1.5707){  // 90 in degrees                   
            out << (theta_i * (180/M_PI)) << "\t\t" << OttoSpr.Reflectance(wavelength, n_prism, real[1], theta_i, real[2], imag[2], thickness[1]) << endl;
            theta_i += step_scale; 
        }
    // stop timer
    timer.stop();
 
    }

    // ***
    // Optical Fiber configuration
    // ***

    L = 20*pow(10,-3);

    if(choose == 3){
        if(mode == 1 & N == 3){
            while (theta_i <= 1.5707){  // 90 in degrees 
                R_AIM = fiber_spr.Reflectance (theta_i, wavelength, n_silica, d_silica, real[1], imag[1], thickness[1], real[2], thickness[2]); 
                T_AIM = fiber_spr.Transmission(theta_i, d_silica, R_AIM, L);   
                out << (theta_i * (180/M_PI)) << "\t\t" << R_AIM << "\t\t" << T_AIM << endl;
                theta_i += step_scale; 
            }
        }

        if(mode == 1 & N == 4){
            while (theta_i <= 1.5707){  // 90 in degrees  
                R_AIM = fiber_spr.Reflectance_4L(theta_i, wavelength, n_silica, d_silica, real[1], imag[1], thickness[1], real[2], imag[2], thickness[2], real[3], thickness[3]);              
                out << (theta_i * (180/M_PI)) << "\t\t" << R_AIM << endl;
                theta_i += step_scale; 
            }
        }

        if(mode == 2){
        
        theta_spr = (M_PI/180)*theta_i;
        double start_wave =  440 * pow (10,-9);
        double end_wave   =  800 * pow (10,-9);
        double step_wave  =  pow(10,-9);

        // Start timer
        timer.start();
            while (start_wave <= end_wave){

                n = metal.n_gold(start_wave);
                k = metal.k_gold(start_wave);
                R_WIM = fiber_spr.ReflectanceWIM(theta_spr, start_wave, n_silica, d_silica, n, k, d_au, n_analyte, d_analyte);
                
                out << start_wave * pow (10,9) << "\t\t" << R_WIM << endl;
                start_wave += step_wave;
            }

        // stop timer
        timer.stop();

        }    
    }

    // ***
    // An user C code can also activate gnuplot and pipe a gnuplot script into it. 
    // ***

    if(choose == 1 || choose == 2){
        fprintf(fp, "set title  \'SPR Curve\'\n" );
        fprintf(fp, "set xlabel \'Incidence Angle (degrees)\'\n" );
        fprintf(fp, "set ylabel \'Reflectance\'\n" );
        fprintf(fp, "set grid \n");     
        fprintf(fp, "plot \'data.dat\' using 1:2 with lines \n");
    }

    if(choose == 3 & mode == 1){
        fprintf(fp, "set title  \'SPR Curve\'\n" );
        fprintf(fp, "set xlabel \'Incidence Angle (degrees)\'\n" );
        fprintf(fp, "set ylabel \'Intensity\'\n" );
        fprintf(fp, "set grid \n");     
        fprintf(fp, "plot \'data.dat\' using 1:2 with lines, \'data.dat\' using 1:3 with points \n");
    }

    if(choose == 3 & mode == 2){

        fprintf(fp, "set title  \'SPR Curve\'\n" );
        fprintf(fp, "set xlabel \'Wavelength (nm)\'\n" );
        fprintf(fp, "set ylabel \'Reflectance\'\n" );
        fprintf(fp, "set grid \n");     
        fprintf(fp, "plot \'data.dat\' using 1:2 with lines \n");
    }
    fflush (fp);
    pclose(fp);

    // ***
    // 
    // ***

    cout << endl;

    out.close();
        
    return 0;
}